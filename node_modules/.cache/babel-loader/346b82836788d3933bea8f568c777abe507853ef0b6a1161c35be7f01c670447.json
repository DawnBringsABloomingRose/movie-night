{"ast":null,"code":"const t = t => \"object\" == typeof t && null != t && 1 === t.nodeType,\n  e = (t, e) => (!e || \"hidden\" !== t) && \"visible\" !== t && \"clip\" !== t,\n  n = (t, n) => {\n    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {\n      const o = getComputedStyle(t, null);\n      return e(o.overflowY, n) || e(o.overflowX, n) || (t => {\n        const e = (t => {\n          if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;\n          try {\n            return t.ownerDocument.defaultView.frameElement;\n          } catch (t) {\n            return null;\n          }\n        })(t);\n        return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);\n      })(t);\n    }\n    return !1;\n  },\n  o = (t, e, n, o, i, l, r, d) => l < t && r > e || l > t && r < e ? 0 : l <= t && d <= n || r >= e && d >= n ? l - t - o : r > e && d < n || l < t && d > n ? r - e + i : 0,\n  i = t => {\n    const e = t.parentElement;\n    return null == e ? t.getRootNode().host || null : e;\n  },\n  l = (e, l) => {\n    var r, d, s, h;\n    if (\"undefined\" == typeof document) return [];\n    const c = l.scrollMode,\n      f = l.block,\n      u = l.inline,\n      a = l.boundary,\n      g = l.skipOverflowHiddenElements,\n      m = \"function\" == typeof a ? a : t => t !== a;\n    if (!t(e)) throw new TypeError(\"Invalid target\");\n    const p = document.scrollingElement || document.documentElement,\n      w = [];\n    let W = e;\n    for (; t(W) && m(W);) {\n      if (W = i(W), W === p) {\n        w.push(W);\n        break;\n      }\n      null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);\n    }\n    const H = null != (d = null == (r = window.visualViewport) ? void 0 : r.width) ? d : innerWidth,\n      b = null != (h = null == (s = window.visualViewport) ? void 0 : s.height) ? h : innerHeight,\n      _window = window,\n      v = _window.scrollX,\n      y = _window.scrollY,\n      _e$getBoundingClientR = e.getBoundingClientRect(),\n      E = _e$getBoundingClientR.height,\n      M = _e$getBoundingClientR.width,\n      x = _e$getBoundingClientR.top,\n      I = _e$getBoundingClientR.right,\n      C = _e$getBoundingClientR.bottom,\n      R = _e$getBoundingClientR.left;\n    let T = \"start\" === f || \"nearest\" === f ? x : \"end\" === f ? C : x + E / 2,\n      V = \"center\" === u ? R + M / 2 : \"end\" === u ? I : R;\n    const k = [];\n    for (let t = 0; t < w.length; t++) {\n      const e = w[t],\n        _e$getBoundingClientR2 = e.getBoundingClientRect(),\n        n = _e$getBoundingClientR2.height,\n        i = _e$getBoundingClientR2.width,\n        l = _e$getBoundingClientR2.top,\n        r = _e$getBoundingClientR2.right,\n        d = _e$getBoundingClientR2.bottom,\n        s = _e$getBoundingClientR2.left;\n      if (\"if-needed\" === c && x >= 0 && R >= 0 && C <= b && I <= H && x >= l && C <= d && R >= s && I <= r) return k;\n      const h = getComputedStyle(e),\n        a = parseInt(h.borderLeftWidth, 10),\n        g = parseInt(h.borderTopWidth, 10),\n        m = parseInt(h.borderRightWidth, 10),\n        W = parseInt(h.borderBottomWidth, 10);\n      let B = 0,\n        D = 0;\n      const L = \"offsetWidth\" in e ? e.offsetWidth - e.clientWidth - a - m : 0,\n        S = \"offsetHeight\" in e ? e.offsetHeight - e.clientHeight - g - W : 0,\n        X = \"offsetWidth\" in e ? 0 === e.offsetWidth ? 0 : i / e.offsetWidth : 0,\n        Y = \"offsetHeight\" in e ? 0 === e.offsetHeight ? 0 : n / e.offsetHeight : 0;\n      if (p === e) B = \"start\" === f ? T : \"end\" === f ? T - b : \"nearest\" === f ? o(y, y + b, b, g, W, y + T, y + T + E, E) : T - b / 2, D = \"start\" === u ? V : \"center\" === u ? V - H / 2 : \"end\" === u ? V - H : o(v, v + H, H, a, m, v + V, v + V + M, M), B = Math.max(0, B + y), D = Math.max(0, D + v);else {\n        B = \"start\" === f ? T - l - g : \"end\" === f ? T - d + W + S : \"nearest\" === f ? o(l, d, n, g, W + S, T, T + E, E) : T - (l + n / 2) + S / 2, D = \"start\" === u ? V - s - a : \"center\" === u ? V - (s + i / 2) + L / 2 : \"end\" === u ? V - r + m + L : o(s, r, i, a, m + L, V, V + M, M);\n        const t = e.scrollLeft,\n          h = e.scrollTop;\n        B = Math.max(0, Math.min(h + B / Y, e.scrollHeight - n / Y + S)), D = Math.max(0, Math.min(t + D / X, e.scrollWidth - i / X + L)), T += h - B, V += t - D;\n      }\n      k.push({\n        el: e,\n        top: B,\n        left: D\n      });\n    }\n    return k;\n  };\nexport { l as compute };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}