{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport warning from \"rc-util/es/warning\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport { isFormInstance } from \"./utils/typeUtil\";\nimport { getNamePath, getValue } from \"./utils/valueUtil\";\nexport function stringify(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    return Math.random();\n  }\n}\nvar useWatchWarning = process.env.NODE_ENV !== 'production' ? function (namePath) {\n  var fullyStr = namePath.join('__RC_FIELD_FORM_SPLIT__');\n  var nameStrRef = useRef(fullyStr);\n  warning(nameStrRef.current === fullyStr, '`useWatch` is not support dynamic `namePath`. Please provide static instead.');\n} : function () {};\nfunction useWatch() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var _args$ = args[0],\n    dependencies = _args$ === void 0 ? [] : _args$,\n    _args$2 = args[1],\n    _form = _args$2 === void 0 ? {} : _args$2;\n  var options = isFormInstance(_form) ? {\n    form: _form\n  } : _form;\n  var form = options.form;\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    value = _useState2[0],\n    setValue = _useState2[1];\n  var valueStr = useMemo(function () {\n    return stringify(value);\n  }, [value]);\n  var valueStrRef = useRef(valueStr);\n  valueStrRef.current = valueStr;\n  var fieldContext = useContext(FieldContext);\n  var formInstance = form || fieldContext;\n  var isValidForm = formInstance && formInstance._init;\n\n  // Warning if not exist form instance\n  if (process.env.NODE_ENV !== 'production') {\n    warning(args.length === 2 ? form ? isValidForm : true : isValidForm, 'useWatch requires a form instance since it can not auto detect from context.');\n  }\n  var namePath = getNamePath(dependencies);\n  var namePathRef = useRef(namePath);\n  namePathRef.current = namePath;\n  useWatchWarning(namePath);\n  useEffect(function () {\n    // Skip if not exist form instance\n    if (!isValidForm) {\n      return;\n    }\n    var getFieldsValue = formInstance.getFieldsValue,\n      getInternalHooks = formInstance.getInternalHooks;\n    var _getInternalHooks = getInternalHooks(HOOK_MARK),\n      registerWatch = _getInternalHooks.registerWatch;\n    var cancelRegister = registerWatch(function (values, allValues) {\n      var newValue = getValue(options.preserve ? allValues : values, namePathRef.current);\n      var nextValueStr = stringify(newValue);\n\n      // Compare stringify in case it's nest object\n      if (valueStrRef.current !== nextValueStr) {\n        valueStrRef.current = nextValueStr;\n        setValue(newValue);\n      }\n    });\n\n    // TODO: We can improve this perf in future\n    var initialValue = getValue(options.preserve ? getFieldsValue(true) : getFieldsValue(), namePathRef.current);\n\n    // React 18 has the bug that will queue update twice even the value is not changed\n    // ref: https://github.com/facebook/react/issues/27213\n    if (value !== initialValue) {\n      setValue(initialValue);\n    }\n    return cancelRegister;\n  },\n  // We do not need re-register since namePath content is the same\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [isValidForm]);\n  return value;\n}\nexport default useWatch;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}